## 목차

- [섹션 2. 문자 인코딩](#섹션-2-문자-인코딩)
- [섹션 3. I/O 기본1](#섹션-3-io-기본1)
- [섹션 4. I/O 기본2](#섹션-4-io-기본2)
- [섹션 5. I/O 활용](#섹션-5-io-활용)
- [섹션 7. 네트워크 - 기본 이론 정리](#섹션-7-네트워크---기본-이론-정리)
- [섹션 8. 네트워크 - 프로그램1](#섹션-8-네트워크---프로그램1)


> 해당 내용은 [자바 실전 자바 고급 2편 - 김영한](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-2/dashboard) 강의를 듣고 정리했습니다.
---
## 섹션 2. 문자 인코딩

### 컴퓨터와 데이터

컴퓨터의 메모리는 반도체로 구성되어 있음. 이것은 수많은 전구처럼 동작하는 **트랜지스터**라는 작은 전자 스위치들로 이루어져 있음.
이 트랜지스터들이 모여서 RAM(Random Access Memory)을 구성함.

* 8bit = 1byte
* 음수 표현 시, 가장 앞의 1bit를 부호 비트로 사용함 (0이면 양수, 1이면 음수)

### 문자 인코딩1

* **문자 인코딩**: 문자를 숫자(바이트)로 변환하는 것
* **문자 디코딩**: 숫자(바이트)를 문자로 변환하는 것
* 인코딩·디코딩은 문자 집합(Charset)을 기준으로 처리됨

### 문자 인코딩2

UTF-8이 사실상 표준이 된 이유는 아래와 같음:

| 이유        | 설명                         |
| --------- | -------------------------- |
| 저장 공간 절약  | 가변 길이 인코딩으로 필요한 만큼만 바이트 사용 |
| 네트워크 효율성  | 영어처럼 ASCII 범위는 1바이트로 처리 가능 |
| ASCII와 호환 | UTF-8의 앞 128문자는 ASCII와 동일함 |

### 문자 집합 조회

JVM에서 지원하는 문자 집합(Charset)을 확인할 수 있음.
예제에서는 `Charset.availableCharsets()`를 사용해 모든 문자 집합을 확인함.

### 문자 인코딩 예제1

* 인코딩: 문자를 컴퓨터가 이해할 수 있는 바이트로 변환하는 작업
* 문자 집합을 지정하지 않으면, 시스템 기본 문자 집합이 사용됨

정리:

* 자바에서 `byte` 타입을 사용해도, 실제 메모리에 저장되는 값은 동일함
* 다만 `byte`는 부호를 포함하므로, **화면 출력 시 10진수 표현**만 다르게 보일 수 있음

### 문자 인코딩 예제2

* ASCII는 UTF-16을 제외한 대부분의 문자 집합과 호환됨

#### 한글이 깨지는 가장 큰 2가지 이유

| 원인        | 설명                                                   |
| --------- | ---------------------------------------------------- |
| 문자 집합 불일치 | EUC-KR(MS949)와 UTF-8은 서로 호환되지 않음                     |
| 잘못된 디코딩   | EUC-KR 또는 UTF-8로 인코딩한 데이터를 ISO-8859-1로 디코딩할 때 한글이 깨짐 |

---

## 섹션 3. I/O 기본1

### 스트림 시작1

* `new FileOutputStream()`: 파일에 데이터를 출력하는 스트림임

    * 파일이 없으면 자동으로 생성되고, 데이터를 해당 파일에 저장함
* `write()`: byte 단위로 값을 출력함
* `new FileInputStream()`: 파일에서 데이터를 읽어오는 스트림임
* `read()`: 파일에서 byte 단위로 읽어옴

    * 더 읽을 내용이 없으면 `-1` 반환 (EOF: End Of File)
* `close()`: 외부 자원은 명시적으로 닫아줘야 함

    * GC는 내부 자원만 자동 정리함

**append 옵션**

| 옵션    | 설명                       |
| ----- | ------------------------ |
| true  | 기존 파일 내용 뒤에 이어서 작성함      |
| false | 기존 파일 내용을 지우고 다시 씀 (기본값) |

---

### 스트림 시작2

**나누어 읽기 vs 전체 읽기**

| 메서드                            | 특징                                              |
| ------------------------------ | ----------------------------------------------- |
| `read(byte[], offset, length)` | 스트림의 일부만 읽거나 반복적으로 읽어야 할 때 유용함<br>메모리 사용량 제어 가능 |
| `readAllBytes()`               | 전체를 한 번에 읽음<br>편하지만 메모리 사용량 제어 어려움              |

---

### InputStream, OutputStream

* 대부분 byte 단위로 데이터 입출력을 처리함
* 데이터를 주고받는 것을 I/O(Input/Output)라고 함

**InputStream 구현체 예시**

* `FileInputStream`, `ByteArrayInputStream`, `SocketInputStream` 등

**OutputStream 구현체 예시**

* `FileOutputStream`, `ByteArrayOutputStream`, `SocketOutputStream` 등

`System.out`은 `PrintStream` 타입 → `OutputStream` 상속

| 메서드               | 제공 주체        | 설명               |
| ----------------- | ------------ | ---------------- |
| `write(byte[])`   | OutputStream | 기본 기능 제공         |
| `println(String)` | PrintStream  | 추가 기능 (문자열 출력 등) |

**정리**

InputStream과 OutputStream은 다양한 스트림 구현체들의 공통 기능을 추상화함

추상화 장점

* 일관성
* 유연성
* 확장성
* 재사용성
* 에러 처리 용이

**참고**

* `InputStream`, `OutputStream`은 추상 클래스임

---

### 파일 입출력과 성능 최적화1 - 하나씩 쓰기

* 10MB 파일을 쓸 때 오래 걸리는 이유는 1byte씩 시스템 콜을 통해 디스크에 쓰기 때문임
* 시스템 콜은 무거운 작업이라서 I/O 성능 저하 발생함

---

### 파일 입출력과 성능 최적화2 - 버퍼 활용

* 버퍼로 많은 데이터를 한 번에 전달하면 성능 최적화 가능
* 단, 버퍼 크기를 무작정 키운다고 성능이 계속 좋아지진 않음

    * 보통 디스크나 파일 시스템의 기본 처리 단위는 4KB 또는 8KB임

---

### 파일 입출력과 성능 최적화3 - Buffered 스트림 쓰기

* `BufferedOutputStream`: 내부에서 버퍼 기능을 제공함 → 성능 개선
* 단독 사용 불가 → `OutputStream`과 연결해서 사용해야 함
* `close()`를 호출하면 내부적으로 `flush()`도 자동 실행됨

**스트림 구분**

| 스트림 종류 | 설명                                            |
| ------ | --------------------------------------------- |
| 기본 스트림 | 단독 사용 가능 (ex. FileOutputStream)               |
| 보조 스트림 | 단독 사용 불가, 보조 기능 제공 (ex. BufferedOutputStream) |

**정리**

* `BufferedOutputStream`은 버퍼 기능을 제공하는 보조 스트림임
* `OutputStream`의 기능 그대로 사용 가능
* 버퍼에 데이터를 모아서 쓰기 때문에 처리 속도 빠름

---

### 파일 입출력과 성능 최적화4 - Buffered 스트림 읽기

* `BufferedInputStream`: 버퍼 크기만큼 데이터를 미리 읽어서 보관함

    * `read()` 호출 시 1byte씩 꺼내도 성능 저하 없음

**성능 차이 이유**

* `BufferedInputStream`은 멀티 쓰레딩을 고려해 동기화 코드 포함되어 있음
  → 싱글 쓰레드에서는 직접 버퍼를 다루는 것보다 오히려 느릴 수 있음

---

### 파일 입출력과 성능 최적화5 - 한 번에 쓰기

* 파일 용량이 작다면 한 번에 읽고 쓰는 것도 가능함
* `readAllBytes()`를 사용하면 전체를 한 번에 읽을 수 있음

---

## 섹션 4. I/O 기본2

### 문자 다루기1 - 시작

* 스트림의 모든 데이터는 byte 단위임
* byte가 아닌 문자를 스트림에 직접 전달할 수 없음 → 문자를 다루려면 별도 변환 필요함

---

### 문자 다루기2 - 스트림을 문자로

* `OutputStreamWriter`: 문자를 받아 지정된 문자셋으로 인코딩하여 byte\[]로 변환 후 출력함
* `InputStreamReader`: byte를 받아 문자(char)로 디코딩함

  * 반환 타입은 `int`인데 실제 문자로 쓰기 위해 `char`로 캐스팅해서 사용함

---

### 문자 다루기3 - Reader, Writer

자바는 **byte용 스트림**, **문자용 스트림**을 구분해서 제공함

| 구분       | 클래스 계층                        | 예시                                                                |
| -------- | ----------------------------- | ----------------------------------------------------------------- |
| byte 스트림 | `InputStream`, `OutputStream` | `FileInputStream`, `BufferedOutputStream`, `ByteArrayInputStream` |
| 문자 스트림   | `Reader`, `Writer`            | `FileWriter`, `BufferedReader`, `OutputStreamWriter`              |

* `OutputStreamWriter`는 `Writer`의 자식 클래스임

  * `write(String)` 가능함
  * 내부적으로 문자를 byte로 변환한 후 `OutputStream` 계열로 전달함
* 모든 데이터는 최종적으로 byte로 저장됨

  * `write(String)` 내부에서도 문자 인코딩 처리 후 byte로 변환되어 저장됨

**정리**

* 문자 다루기에는 `Reader`, `Writer` 계열이 편함
* 하지만 내부적으로는 결국 byte로 변환됨

---

### 문자 다루기4 - BufferedReader

* `BufferedReader`는 문자 데이터를 **한 줄 단위로 읽을 수 있음** (`readLine()` 지원)

---

### 기타 스트림

#### PrintStream

* `System.out`에 사용되는 출력 스트림
* `PrintStream` + `FileOutputStream`을 조합하면 **콘솔 출력처럼 파일 출력 가능함**

#### DataOutputStream

* `int`, `double`, `boolean`, `String` 같은 **기본형 타입을 편리하게 출력 가능**
* 바이너리 형식으로 저장함 → 읽을 땐 `DataInputStream` 필요함

---
## 섹션 5. I/O 활용

### 회원 관리 예제 - 저장 방식별 비교

| 예제                       | 설명                                                                              |
| ------------------------ | ------------------------------------------------------------------------------- |
| 회원 관리 예제1 - 메모리          | 데이터를 메모리에만 저장함. 프로그램 종료 시 데이터 모두 사라짐                                            |
| 회원 관리 예제2 - 파일에 보관       | 파일에 텍스트 형태로 저장함. 프로그램을 껐다 켜도 데이터 유지됨                                            |
| 회원 관리 예제3 - DataStream   | `DataOutputStream`, `DataInputStream` 사용해서 기본형 데이터(int, String 등)를 바이너리 형식으로 저장 |
| 회원 관리 예제4 - ObjectStream | `ObjectOutputStream`, `ObjectInputStream` 사용해서 객체 자체를 통째로 저장하고 복원함              |

---

### 객체 직렬화(Serialization)

* 메모리에 있는 객체 인스턴스를 바이트 스트림으로 변환해서 파일에 저장하거나 네트워크로 전송 가능함
* 직렬화된 데이터를 다시 객체로 복원하는 걸 역직렬화(Deserialization)이라고 함
* 직렬화하려면 해당 클래스가 `Serializable` 인터페이스를 구현해야 함

```java
class Member implements Serializable {
    private String name;
    private int age;
}
```

---

### 객체 직렬화를 사용하지 않는 이유

| 한계점       | 설명                                                            |
| --------- | ------------------------------------------------------------- |
| 버전 관리 어려움 | 클래스 구조가 바뀌면 기존 직렬화된 데이터와 호환되지 않음. `serialVersionUID` 관리도 번거로움 |
| 플랫폼 종속성   | 직렬화된 데이터가 자바 환경에 종속적임                                         |
| 성능 이슈     | 데이터 크기가 크고, 읽고 쓰는 속도도 느림                                      |
| 유연성 부족    | 데이터 구조 변경이나 확장에 유연하지 않음                                       |
| 크기 비효율성   | JSON 등 다른 형식에 비해 데이터 크기가 큼                                    |

---

### 정리

* 자바의 객체 직렬화 기능은 거의 사용하지 않음
* JSON이 사실상 표준으로 사용되고 있음
* 성능 최적화가 중요하면 Protobuf, Avro 같은 바이너리 포맷도 고려함

---

## 섹션 7. 네트워크 - 기본 이론 정리

### 클라이언트와 서버

* 클라이언트-서버 모델은 서비스를 요청하는 주체(클라이언트)와, 그 요청을 처리해 서비스를 제공하는 주체(서버) 간의 관계임

---

### 인터넷 통신

* 인터넷에서 두 컴퓨터가 통신하기 위해 IP(인터넷 프로토콜)를 사용함

---

### IP (Internet Protocol)

**IP의 역할**

* IP 주소 기반으로 데이터 전달함
* 데이터를 **패킷**이라는 단위로 나누어 전송함
* 패킷에는 출발지, 목적지 IP, 메시지 등의 정보가 담김
* 인터넷 망의 라우터들이 이 정보를 바탕으로 목적지까지 패킷을 전달함

**IP의 한계**

| 한계         | 설명                                             |
| ---------- | ---------------------------------------------- |
| 비연결성       | 수신자가 없거나 문제가 있어도 일단 전송함                        |
| 비신뢰성       | 패킷이 중간에 사라질 수도 있고, 순서대로 도착하지 않을 수도 있음          |
| 프로그램 구분 불가 | 동일한 IP 주소를 사용하는 서버에서 어떤 애플리케이션과 통신해야 하는지 식별 불가 |

---

### TCP / UDP

**인터넷 프로토콜 스택의 4계층 구조**

| 계층            | 예시 프로토콜      |
| ------------- | ------------ |
| 애플리케이션 계층     | HTTP, FTP    |
| 전송 계층         | TCP, UDP     |
| 인터넷 계층        | IP           |
| 네트워크 인터페이스 계층 | (LAN 등 물리계층) |

**TCP (Transmission Control Protocol)**

* 연결 지향 방식 (3-way handshake)
* 데이터 전달 보장
* 순서 보장
* 신뢰성 높은 프로토콜임

**UDP (User Datagram Protocol)**

* 연결 없이 빠르게 전송
* 데이터 전달과 순서를 보장하지 않음
* 단순하고 빠르기 때문에 실시간 성능이 중요한 분야(예: 영상 스트리밍, 게임)에 사용됨

---

### PORT

* 같은 IP 주소 내에서 여러 프로그램(서버 소프트웨어)이 동시에 통신할 수 있도록 **PORT 번호**로 구분함

* 하나의 TCP/IP 패킷에는 다음 정보가 포함됨:

  * 출발지 IP, 출발지 PORT
  * 도착지 IP, 도착지 PORT

---

### DNS (Domain Name System)

* IP 주소는 기억하기 어렵고 변경될 수 있음
* **DNS**는 사람이 기억하기 쉬운 도메인 이름을 IP 주소로 변환해주는 시스템임
  예) `www.example.com` → `192.0.2.1`

---

## 섹션 8. 네트워크 - 프로그램1

### 통신 대상 찾기

* TCP/IP 통신 시 **IP 주소**가 필요함
* `InetAddress` 클래스를 사용하면 **호스트 이름으로 IP를 찾을 수 있음**

### 클라이언트 → 서버 연결

```java
Socket socket = new Socket("localhost", 12345);
```

* `localhost`는 IP가 아님 → 내부적으로 `InetAddress` 통해 IP로 변환됨
* `localhost`는 `127.0.0.1`로 매핑되어 있음
* `127.0.0.1:12345`로 TCP 접속 시도
* 연결되면 `Socket` 객체 반환 → 이 객체를 통해 서버와 통신 가능

### 서버 연결 동작 원리

* 서버는 `12345` 포트로 `ServerSocket`을 열고 대기
* 클라이언트가 접속하면 OS는 **TCP 3-way handshake** 수행
* 연결이 성립되면 OS의 **backlog queue**에 클라이언트와 서버의 연결 정보(IP, 포트 등)를 저장

### TCP 연결 시 포트 정보

| 구분    | IP        | Port  |
| ----- | --------- | ----- |
| 클라이언트 | 127.0.0.1 | 랜덤 포트 |
| 서버    | 127.0.0.1 | 12345 |

### `accept()` 메서드

```java
Socket socket = serverSocket.accept();
```

* 클라이언트의 TCP 연결 요청을 수락하고 `Socket` 객체를 반환
* 반환된 `Socket`으로 클라이언트와 메시지 송수신 가능

---

### 네트워크 프로그램2

### 메시지 흐름

* 클라이언트:

  * 애플리케이션 → OS TCP 송신 버퍼 → 네트워크 카드
* 서버:

  * 네트워크 카드 → OS TCP 수신 버퍼 → 애플리케이션

### 서버 소켓의 역할

* `ServerSocket`만으로도 TCP 연결은 가능함
* 실제 메시지 송수신은 `Socket` 객체로 수행해야 함

### ServerV2의 문제점

* 여러 클라이언트 연결 불가
* `accept()`는 블로킹 메서드라 한 번 연결되면 다음 클라이언트 연결을 받지 못함

### 해결책: 쓰레드 분리 필요

| 메서드         | 역할              | 문제점                 |
| ----------- | --------------- | ------------------- |
| `accept()`  | 연결 요청 수락 (블로킹)  | 연결 대기 중 다른 작업 불가    |
| `readXxx()` | 메시지 수신 대기 (블로킹) | 메시지 기다리는 동안 연결 못 받음 |

→ **각 블로킹 작업은 별도 쓰레드에서 처리해야 함**

---

### 네트워크 프로그램3

### 역할 분리

* main 쓰레드: 연결 수락 → `Session` 객체와 쓰레드 생성
* Session 쓰레드: 해당 클라이언트와 메시지를 주고받는 역할 담당

### TCP 연결 종료

* 클라이언트가 종료되면 TCP 연결도 종료됨
* 서버 측에서는 `readUTF()` 호출 시 `EOFException` 발생

  * 더 이상 읽을 수 있는 메시지가 없다는 뜻
  * 서버에서 자원 정리 코드 호출이 누락될 수 있음

### GC와 자원 정리

* 자바 객체는 GC의 대상이지만, 외부 자원(Socket 등)은 **명시적으로 닫아야 함**

---

### 자원 정리1

### 문제점

* 예외 발생 시 자원이 닫히지 않을 수 있음

---

### 자원 정리2

### 문제점

* `close()` 중 예외 발생 → 이후 자원 닫기 실패
* `finally` 블럭에서 예외 발생 시 **핵심 예외가 가려짐**

---

### 자원 정리3

### 해결 방법

* `try-catch`로 자원 정리 중 예외를 처리
* 자원을 순차적으로 안전하게 닫을 수 있음
* 자원 정리 중 발생한 예외는 **로그로 남기는 수준으로 처리**

### 아쉬운 점

| 문제점                 | 설명                              |
| ------------------- | ------------------------------- |
| 변수 선언과 동시에 할당 불가    | try 블럭 외에서 선언하고 할당해야 함          |
| catch 이후 finally 호출 | 자원 정리 시점이 늦어짐                   |
| close() 호출 누락 위험    | 사람이 직접 닫아야 하므로 실수할 가능성 있음       |
| close() 순서 실수 가능    | 생성 순서와 반대로 닫아야 하지만 지켜지지 않을 수 있음 |

---

### 자원 정리4

### try-with-resources 장점

| 기능           | 기존 방식                  | try-with-resources 방식 |
| ------------ | ---------------------- | --------------------- |
| 자원 자동 닫기     | 개발자가 직접 close 호출       | 자동으로 close 호출         |
| 예외 처리 순서     | 핵심 예외가 부가 예외에 가려짐      | Suppressed로 보존됨       |
| 코드 간결성 및 가독성 | try-catch-finally 반복적임 | 간결하고 명확함              |
| 자원 선언 위치 제한  | try 외부에서 선언 필요         | try 내에서 선언 가능         |
| 자원 정리 순서     | 수동 정리 필요               | 선언 반대 순서로 자동 정리       |
| 자원 해제 시점     | finally에서 닫힘           | try 종료와 동시에 닫힘        |

### 예외 처리

* 핵심 로직에서 발생한 예외를 **기본 예외**로 처리
* 자원 닫기 중 발생한 예외는 **Suppressed 예외**로 보존

---


