## 목차

- [섹션 2. 문자 인코딩](#섹션-2-문자-인코딩)
- [섹션 3. I/O 기본1](#섹션-3-io-기본1)
- [섹션 4. I/O 기본2](#섹션-4-io-기본2)


> 해당 내용은 [자바 실전 자바 고급 2편 - 김영한](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-2/dashboard) 강의를 듣고 정리했습니다.
---
## 섹션 2. 문자 인코딩

### 컴퓨터와 데이터

컴퓨터의 메모리는 반도체로 구성되어 있음. 이것은 수많은 전구처럼 동작하는 **트랜지스터**라는 작은 전자 스위치들로 이루어져 있음.
이 트랜지스터들이 모여서 RAM(Random Access Memory)을 구성함.

* 8bit = 1byte
* 음수 표현 시, 가장 앞의 1bit를 부호 비트로 사용함 (0이면 양수, 1이면 음수)

### 문자 인코딩1

* **문자 인코딩**: 문자를 숫자(바이트)로 변환하는 것
* **문자 디코딩**: 숫자(바이트)를 문자로 변환하는 것
* 인코딩·디코딩은 문자 집합(Charset)을 기준으로 처리됨

### 문자 인코딩2

UTF-8이 사실상 표준이 된 이유는 아래와 같음:

| 이유        | 설명                         |
| --------- | -------------------------- |
| 저장 공간 절약  | 가변 길이 인코딩으로 필요한 만큼만 바이트 사용 |
| 네트워크 효율성  | 영어처럼 ASCII 범위는 1바이트로 처리 가능 |
| ASCII와 호환 | UTF-8의 앞 128문자는 ASCII와 동일함 |

### 문자 집합 조회

JVM에서 지원하는 문자 집합(Charset)을 확인할 수 있음.
예제에서는 `Charset.availableCharsets()`를 사용해 모든 문자 집합을 확인함.

### 문자 인코딩 예제1

* 인코딩: 문자를 컴퓨터가 이해할 수 있는 바이트로 변환하는 작업
* 문자 집합을 지정하지 않으면, 시스템 기본 문자 집합이 사용됨

정리:

* 자바에서 `byte` 타입을 사용해도, 실제 메모리에 저장되는 값은 동일함
* 다만 `byte`는 부호를 포함하므로, **화면 출력 시 10진수 표현**만 다르게 보일 수 있음

### 문자 인코딩 예제2

* ASCII는 UTF-16을 제외한 대부분의 문자 집합과 호환됨

#### 한글이 깨지는 가장 큰 2가지 이유

| 원인        | 설명                                                   |
| --------- | ---------------------------------------------------- |
| 문자 집합 불일치 | EUC-KR(MS949)와 UTF-8은 서로 호환되지 않음                     |
| 잘못된 디코딩   | EUC-KR 또는 UTF-8로 인코딩한 데이터를 ISO-8859-1로 디코딩할 때 한글이 깨짐 |

---

## 섹션 3. I/O 기본1

### 스트림 시작1

* `new FileOutputStream()`: 파일에 데이터를 출력하는 스트림임

    * 파일이 없으면 자동으로 생성되고, 데이터를 해당 파일에 저장함
* `write()`: byte 단위로 값을 출력함
* `new FileInputStream()`: 파일에서 데이터를 읽어오는 스트림임
* `read()`: 파일에서 byte 단위로 읽어옴

    * 더 읽을 내용이 없으면 `-1` 반환 (EOF: End Of File)
* `close()`: 외부 자원은 명시적으로 닫아줘야 함

    * GC는 내부 자원만 자동 정리함

**append 옵션**

| 옵션    | 설명                       |
| ----- | ------------------------ |
| true  | 기존 파일 내용 뒤에 이어서 작성함      |
| false | 기존 파일 내용을 지우고 다시 씀 (기본값) |

---

### 스트림 시작2

**나누어 읽기 vs 전체 읽기**

| 메서드                            | 특징                                              |
| ------------------------------ | ----------------------------------------------- |
| `read(byte[], offset, length)` | 스트림의 일부만 읽거나 반복적으로 읽어야 할 때 유용함<br>메모리 사용량 제어 가능 |
| `readAllBytes()`               | 전체를 한 번에 읽음<br>편하지만 메모리 사용량 제어 어려움              |

---

### InputStream, OutputStream

* 대부분 byte 단위로 데이터 입출력을 처리함
* 데이터를 주고받는 것을 I/O(Input/Output)라고 함

**InputStream 구현체 예시**

* `FileInputStream`, `ByteArrayInputStream`, `SocketInputStream` 등

**OutputStream 구현체 예시**

* `FileOutputStream`, `ByteArrayOutputStream`, `SocketOutputStream` 등

`System.out`은 `PrintStream` 타입 → `OutputStream` 상속

| 메서드               | 제공 주체        | 설명               |
| ----------------- | ------------ | ---------------- |
| `write(byte[])`   | OutputStream | 기본 기능 제공         |
| `println(String)` | PrintStream  | 추가 기능 (문자열 출력 등) |

**정리**

InputStream과 OutputStream은 다양한 스트림 구현체들의 공통 기능을 추상화함

추상화 장점

* 일관성
* 유연성
* 확장성
* 재사용성
* 에러 처리 용이

**참고**

* `InputStream`, `OutputStream`은 추상 클래스임

---

### 파일 입출력과 성능 최적화1 - 하나씩 쓰기

* 10MB 파일을 쓸 때 오래 걸리는 이유는 1byte씩 시스템 콜을 통해 디스크에 쓰기 때문임
* 시스템 콜은 무거운 작업이라서 I/O 성능 저하 발생함

---

### 파일 입출력과 성능 최적화2 - 버퍼 활용

* 버퍼로 많은 데이터를 한 번에 전달하면 성능 최적화 가능
* 단, 버퍼 크기를 무작정 키운다고 성능이 계속 좋아지진 않음

    * 보통 디스크나 파일 시스템의 기본 처리 단위는 4KB 또는 8KB임

---

### 파일 입출력과 성능 최적화3 - Buffered 스트림 쓰기

* `BufferedOutputStream`: 내부에서 버퍼 기능을 제공함 → 성능 개선
* 단독 사용 불가 → `OutputStream`과 연결해서 사용해야 함
* `close()`를 호출하면 내부적으로 `flush()`도 자동 실행됨

**스트림 구분**

| 스트림 종류 | 설명                                            |
| ------ | --------------------------------------------- |
| 기본 스트림 | 단독 사용 가능 (ex. FileOutputStream)               |
| 보조 스트림 | 단독 사용 불가, 보조 기능 제공 (ex. BufferedOutputStream) |

**정리**

* `BufferedOutputStream`은 버퍼 기능을 제공하는 보조 스트림임
* `OutputStream`의 기능 그대로 사용 가능
* 버퍼에 데이터를 모아서 쓰기 때문에 처리 속도 빠름

---

### 파일 입출력과 성능 최적화4 - Buffered 스트림 읽기

* `BufferedInputStream`: 버퍼 크기만큼 데이터를 미리 읽어서 보관함

    * `read()` 호출 시 1byte씩 꺼내도 성능 저하 없음

**성능 차이 이유**

* `BufferedInputStream`은 멀티 쓰레딩을 고려해 동기화 코드 포함되어 있음
  → 싱글 쓰레드에서는 직접 버퍼를 다루는 것보다 오히려 느릴 수 있음

---

### 파일 입출력과 성능 최적화5 - 한 번에 쓰기

* 파일 용량이 작다면 한 번에 읽고 쓰는 것도 가능함
* `readAllBytes()`를 사용하면 전체를 한 번에 읽을 수 있음

---

## 섹션 4. I/O 기본2

### 문자 다루기1 - 시작

* 스트림의 모든 데이터는 byte 단위임
* byte가 아닌 문자를 스트림에 직접 전달할 수 없음 → 문자를 다루려면 별도 변환 필요함

---

### 문자 다루기2 - 스트림을 문자로

* `OutputStreamWriter`: 문자를 받아 지정된 문자셋으로 인코딩하여 byte\[]로 변환 후 출력함
* `InputStreamReader`: byte를 받아 문자(char)로 디코딩함

  * 반환 타입은 `int`인데 실제 문자로 쓰기 위해 `char`로 캐스팅해서 사용함

---

### 문자 다루기3 - Reader, Writer

자바는 **byte용 스트림**, **문자용 스트림**을 구분해서 제공함

| 구분       | 클래스 계층                        | 예시                                                                |
| -------- | ----------------------------- | ----------------------------------------------------------------- |
| byte 스트림 | `InputStream`, `OutputStream` | `FileInputStream`, `BufferedOutputStream`, `ByteArrayInputStream` |
| 문자 스트림   | `Reader`, `Writer`            | `FileWriter`, `BufferedReader`, `OutputStreamWriter`              |

* `OutputStreamWriter`는 `Writer`의 자식 클래스임

  * `write(String)` 가능함
  * 내부적으로 문자를 byte로 변환한 후 `OutputStream` 계열로 전달함
* 모든 데이터는 최종적으로 byte로 저장됨

  * `write(String)` 내부에서도 문자 인코딩 처리 후 byte로 변환되어 저장됨

**정리**

* 문자 다루기에는 `Reader`, `Writer` 계열이 편함
* 하지만 내부적으로는 결국 byte로 변환됨

---

### 문자 다루기4 - BufferedReader

* `BufferedReader`는 문자 데이터를 **한 줄 단위로 읽을 수 있음** (`readLine()` 지원)

---

### 기타 스트림

#### PrintStream

* `System.out`에 사용되는 출력 스트림
* `PrintStream` + `FileOutputStream`을 조합하면 **콘솔 출력처럼 파일 출력 가능함**

#### DataOutputStream

* `int`, `double`, `boolean`, `String` 같은 **기본형 타입을 편리하게 출력 가능**
* 바이너리 형식으로 저장함 → 읽을 땐 `DataInputStream` 필요함

---
